# gRPC-Go å®è·µé¡¹ç›®ç¤ºä¾‹

## ğŸ¯ é¡¹ç›®ç›®æ ‡
é€šè¿‡å®é™…é¡¹ç›®å¼€å‘ï¼Œæ·±å…¥ç†è§£å’Œåº”ç”¨ gRPC-Go çš„æ ¸å¿ƒæ¦‚å¿µå’Œæœ€ä½³å®è·µã€‚

## ğŸ“‹ é¡¹ç›®åˆ—è¡¨

### é¡¹ç›®1: ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ (åŸºç¡€ RPC)

#### 1.1 é¡¹ç›®æ¦‚è¿°
å®ç°ä¸€ä¸ªå®Œæ•´çš„ç”¨æˆ·ç®¡ç†ç³»ç»Ÿï¼ŒåŒ…å«ç”¨æˆ·çš„å¢åˆ æ”¹æŸ¥æ“ä½œï¼Œä½¿ç”¨ä¸€å…ƒ RPC æ¨¡å¼ã€‚

#### 1.2 æŠ€æœ¯æ ˆ
- **gRPC-Go**: é€šä¿¡æ¡†æ¶
- **Protocol Buffers**: æ•°æ®åºåˆ—åŒ–
- **SQLite**: æ•°æ®å­˜å‚¨
- **Gin**: HTTP ç½‘å…³ (å¯é€‰)

#### 1.3 é¡¹ç›®ç»“æ„
```
user-service/
â”œâ”€â”€ proto/
â”‚   â””â”€â”€ user.proto
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ main.go
â”‚   â”œâ”€â”€ handler.go
â”‚   â””â”€â”€ database.go
â”œâ”€â”€ client/
â”‚   â””â”€â”€ main.go
â”œâ”€â”€ gateway/
â”‚   â””â”€â”€ main.go
â””â”€â”€ go.mod
```

#### 1.4 æ ¸å¿ƒå®ç°

**proto/user.proto**:
```protobuf
syntax = "proto3";

package user;

option go_package = "github.com/your-username/user-service/proto";

service UserService {
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);
  rpc ListUsers(ListUsersRequest) returns (ListUsersResponse);
}

message User {
  int64 id = 1;
  string username = 2;
  string email = 3;
  string full_name = 4;
  string created_at = 5;
  string updated_at = 6;
}

message CreateUserRequest {
  string username = 1;
  string email = 2;
  string full_name = 3;
}

message CreateUserResponse {
  User user = 1;
}

message GetUserRequest {
  int64 id = 1;
}

message GetUserResponse {
  User user = 1;
}

message UpdateUserRequest {
  int64 id = 1;
  string username = 2;
  string email = 3;
  string full_name = 4;
}

message UpdateUserResponse {
  User user = 1;
}

message DeleteUserRequest {
  int64 id = 1;
}

message DeleteUserResponse {
  bool success = 1;
}

message ListUsersRequest {
  int32 page = 1;
  int32 page_size = 2;
}

message ListUsersResponse {
  repeated User users = 1;
  int32 total = 2;
}
```

**server/handler.go**:
```go
package main

import (
    "context"
    "database/sql"
    "time"
    
    pb "github.com/your-username/user-service/proto"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

type userServer struct {
    pb.UnimplementedUserServiceServer
    db *sql.DB
}

func (s *userServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {
    // å‚æ•°éªŒè¯
    if req.Username == "" || req.Email == "" {
        return nil, status.Error(codes.InvalidArgument, "username and email are required")
    }
    
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    var exists bool
    err := s.db.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ? OR email = ?)", 
        req.Username, req.Email).Scan(&exists)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "database error: %v", err)
    }
    if exists {
        return nil, status.Error(codes.AlreadyExists, "user already exists")
    }
    
    // åˆ›å»ºç”¨æˆ·
    now := time.Now().Format(time.RFC3339)
    result, err := s.db.ExecContext(ctx, 
        "INSERT INTO users (username, email, full_name, created_at, updated_at) VALUES (?, ?, ?, ?, ?)",
        req.Username, req.Email, req.FullName, now, now)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to create user: %v", err)
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to get user id: %v", err)
    }
    
    user := &pb.User{
        Id:        id,
        Username:  req.Username,
        Email:     req.Email,
        FullName:  req.FullName,
        CreatedAt: now,
        UpdatedAt: now,
    }
    
    return &pb.CreateUserResponse{User: user}, nil
}

func (s *userServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
    if req.Id <= 0 {
        return nil, status.Error(codes.InvalidArgument, "invalid user id")
    }
    
    var user pb.User
    err := s.db.QueryRowContext(ctx, 
        "SELECT id, username, email, full_name, created_at, updated_at FROM users WHERE id = ?",
        req.Id).Scan(&user.Id, &user.Username, &user.Email, &user.FullName, &user.CreatedAt, &user.UpdatedAt)
    
    if err == sql.ErrNoRows {
        return nil, status.Error(codes.NotFound, "user not found")
    }
    if err != nil {
        return nil, status.Errorf(codes.Internal, "database error: %v", err)
    }
    
    return &pb.GetUserResponse{User: &user}, nil
}

func (s *userServer) UpdateUser(ctx context.Context, req *pb.UpdateUserRequest) (*pb.UpdateUserResponse, error) {
    if req.Id <= 0 {
        return nil, status.Error(codes.InvalidArgument, "invalid user id")
    }
    
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    var exists bool
    err := s.db.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE id = ?)", req.Id).Scan(&exists)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "database error: %v", err)
    }
    if !exists {
        return nil, status.Error(codes.NotFound, "user not found")
    }
    
    // æ›´æ–°ç”¨æˆ·
    now := time.Now().Format(time.RFC3339)
    _, err = s.db.ExecContext(ctx, 
        "UPDATE users SET username = ?, email = ?, full_name = ?, updated_at = ? WHERE id = ?",
        req.Username, req.Email, req.FullName, now, req.Id)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to update user: %v", err)
    }
    
    // è·å–æ›´æ–°åçš„ç”¨æˆ·ä¿¡æ¯
    user := &pb.User{
        Id:        req.Id,
        Username:  req.Username,
        Email:     req.Email,
        FullName:  req.FullName,
        UpdatedAt: now,
    }
    
    return &pb.UpdateUserResponse{User: user}, nil
}

func (s *userServer) DeleteUser(ctx context.Context, req *pb.DeleteUserRequest) (*pb.DeleteUserResponse, error) {
    if req.Id <= 0 {
        return nil, status.Error(codes.InvalidArgument, "invalid user id")
    }
    
    result, err := s.db.ExecContext(ctx, "DELETE FROM users WHERE id = ?", req.Id)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to delete user: %v", err)
    }
    
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to get rows affected: %v", err)
    }
    
    if rowsAffected == 0 {
        return nil, status.Error(codes.NotFound, "user not found")
    }
    
    return &pb.DeleteUserResponse{Success: true}, nil
}

func (s *userServer) ListUsers(ctx context.Context, req *pb.ListUsersRequest) (*pb.ListUsersResponse, error) {
    // åˆ†é¡µå‚æ•°éªŒè¯
    if req.Page <= 0 {
        req.Page = 1
    }
    if req.PageSize <= 0 || req.PageSize > 100 {
        req.PageSize = 20
    }
    
    offset := (req.Page - 1) * req.PageSize
    
    // è·å–æ€»æ•°
    var total int32
    err := s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM users").Scan(&total)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to count users: %v", err)
    }
    
    // è·å–ç”¨æˆ·åˆ—è¡¨
    rows, err := s.db.QueryContext(ctx, 
        "SELECT id, username, email, full_name, created_at, updated_at FROM users ORDER BY id LIMIT ? OFFSET ?",
        req.PageSize, offset)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to query users: %v", err)
    }
    defer rows.Close()
    
    var users []*pb.User
    for rows.Next() {
        var user pb.User
        err := rows.Scan(&user.Id, &user.Username, &user.Email, &user.FullName, &user.CreatedAt, &user.UpdatedAt)
        if err != nil {
            return nil, status.Errorf(codes.Internal, "failed to scan user: %v", err)
        }
        users = append(users, &user)
    }
    
    if err = rows.Err(); err != nil {
        return nil, status.Errorf(codes.Internal, "rows error: %v", err)
    }
    
    return &pb.ListUsersResponse{
        Users: users,
        Total: total,
    }, nil
}
```

**server/main.go**:
```go
package main

import (
    "database/sql"
    "flag"
    "log"
    "net"
    
    _ "github.com/mattn/go-sqlite3"
    pb "github.com/your-username/user-service/proto"
    "google.golang.org/grpc"
    "google.golang.org/grpc/reflection"
)

var (
    port = flag.Int("port", 50051, "The server port")
    dbPath = flag.String("db", "users.db", "Database file path")
)

func main() {
    flag.Parse()
    
    // åˆå§‹åŒ–æ•°æ®åº“
    db, err := sql.Open("sqlite3", *dbPath)
    if err != nil {
        log.Fatalf("failed to open database: %v", err)
    }
    defer db.Close()
    
    // åˆ›å»ºè¡¨
    if err := createTable(db); err != nil {
        log.Fatalf("failed to create table: %v", err)
    }
    
    // åˆ›å»º gRPC æœåŠ¡å™¨
    s := grpc.NewServer()
    pb.RegisterUserServiceServer(s, &userServer{db: db})
    
    // å¯ç”¨åå°„æœåŠ¡ (ç”¨äºè°ƒè¯•)
    reflection.Register(s)
    
    // å¯åŠ¨ç›‘å¬
    lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    
    log.Printf("server listening at %v", lis.Addr())
    if err := s.Serve(lis); err != nil {
        log.Fatalf("failed to serve: %v", err)
    }
}

func createTable(db *sql.DB) error {
    query := `
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        email TEXT UNIQUE NOT NULL,
        full_name TEXT,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
    );
    `
    _, err := db.Exec(query)
    return err
}
```

### é¡¹ç›®2: å®æ—¶èŠå¤©ç³»ç»Ÿ (æµå¼é€šä¿¡)

#### 2.1 é¡¹ç›®æ¦‚è¿°
å®ç°ä¸€ä¸ªå®æ—¶èŠå¤©ç³»ç»Ÿï¼Œæ”¯æŒå¤šæˆ¿é—´èŠå¤©ï¼Œä½¿ç”¨åŒå‘æµ RPCã€‚

#### 2.2 æŠ€æœ¯æ ˆ
- **gRPC-Go**: é€šä¿¡æ¡†æ¶
- **Protocol Buffers**: æ•°æ®åºåˆ—åŒ–
- **Redis**: æ¶ˆæ¯å­˜å‚¨å’Œæˆ¿é—´ç®¡ç†
- **WebSocket**: å‰ç«¯é€šä¿¡ (å¯é€‰)

#### 2.3 é¡¹ç›®ç»“æ„
```
chat-service/
â”œâ”€â”€ proto/
â”‚   â””â”€â”€ chat.proto
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ main.go
â”‚   â”œâ”€â”€ handler.go
â”‚   â”œâ”€â”€ room.go
â”‚   â””â”€â”€ redis.go
â”œâ”€â”€ client/
â”‚   â””â”€â”€ main.go
â”œâ”€â”€ web/
â”‚   â”œâ”€â”€ index.html
â”‚   â””â”€â”€ app.js
â””â”€â”€ go.mod
```

#### 2.4 æ ¸å¿ƒå®ç°

**proto/chat.proto**:
```protobuf
syntax = "proto3";

package chat;

option go_package = "github.com/your-username/chat-service/proto";

service ChatService {
  rpc JoinRoom(JoinRoomRequest) returns (stream ChatMessage);
  rpc SendMessage(ChatMessage) returns (SendMessageResponse);
  rpc ListRooms(ListRoomsRequest) returns (ListRoomsResponse);
  rpc GetRoomInfo(GetRoomInfoRequest) returns (GetRoomInfoResponse);
}

message ChatMessage {
  string id = 1;
  string room_id = 2;
  string user_id = 3;
  string username = 4;
  string content = 5;
  string timestamp = 6;
  MessageType type = 7;
}

enum MessageType {
  MESSAGE_TYPE_UNSPECIFIED = 0;
  MESSAGE_TYPE_TEXT = 1;
  MESSAGE_TYPE_JOIN = 2;
  MESSAGE_TYPE_LEAVE = 3;
  MESSAGE_TYPE_SYSTEM = 4;
}

message JoinRoomRequest {
  string room_id = 1;
  string user_id = 2;
  string username = 3;
}

message SendMessageResponse {
  bool success = 1;
  string message_id = 2;
}

message ListRoomsRequest {}

message ListRoomsResponse {
  repeated RoomInfo rooms = 1;
}

message RoomInfo {
  string id = 1;
  string name = 2;
  int32 user_count = 3;
  string created_at = 4;
}

message GetRoomInfoRequest {
  string room_id = 1;
}

message GetRoomInfoResponse {
  RoomInfo room = 1;
  repeated string user_ids = 2;
}
```

**server/room.go**:
```go
package main

import (
    "context"
    "sync"
    "time"
    
    pb "github.com/your-username/chat-service/proto"
)

type Room struct {
    ID        string
    Name      string
    CreatedAt time.Time
    mu        sync.RWMutex
    clients   map[string]*Client
    messages  []*pb.ChatMessage
    maxMessages int
}

type Client struct {
    ID       string
    Username string
    RoomID   string
    Stream   pb.ChatService_JoinRoomServer
    ctx      context.Context
    cancel   context.CancelFunc
}

func NewRoom(id, name string) *Room {
    return &Room{
        ID:          id,
        Name:        name,
        CreatedAt:   time.Now(),
        clients:     make(map[string]*Client),
        messages:    make([]*pb.ChatMessage, 0),
        maxMessages: 1000, // ä¿ç•™æœ€è¿‘1000æ¡æ¶ˆæ¯
    }
}

func (r *Room) AddClient(client *Client) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.clients[client.ID] = client
    
    // å‘é€åŠ å…¥æ¶ˆæ¯
    joinMsg := &pb.ChatMessage{
        Id:        generateMessageID(),
        RoomId:    r.ID,
        UserId:    client.ID,
        Username:  client.Username,
        Content:   client.Username + " joined the room",
        Timestamp: time.Now().Format(time.RFC3339),
        Type:      pb.MessageType_MESSAGE_TYPE_JOIN,
    }
    
    r.addMessage(joinMsg)
    r.broadcast(joinMsg, client.ID) // ä¸å‘é€ç»™å‘é€è€…
}

func (r *Room) RemoveClient(clientID string) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    client, exists := r.clients[clientID]
    if !exists {
        return
    }
    
    delete(r.clients, clientID)
    client.cancel()
    
    // å‘é€ç¦»å¼€æ¶ˆæ¯
    leaveMsg := &pb.ChatMessage{
        Id:        generateMessageID(),
        RoomId:    r.ID,
        UserId:    client.ID,
        Username:  client.Username,
        Content:   client.Username + " left the room",
        Timestamp: time.Now().Format(time.RFC3339),
        Type:      pb.MessageType_MESSAGE_TYPE_LEAVE,
    }
    
    r.addMessage(leaveMsg)
    r.broadcast(leaveMsg, "")
}

func (r *Room) Broadcast(message *pb.ChatMessage) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    r.addMessage(message)
    r.broadcast(message, message.UserId)
}

func (r *Room) broadcast(message *pb.ChatMessage, excludeUserID string) {
    for clientID, client := range r.clients {
        if clientID == excludeUserID {
            continue
        }
        
        select {
        case <-client.ctx.Done():
            // å®¢æˆ·ç«¯å·²æ–­å¼€ï¼Œç¨åæ¸…ç†
            continue
        default:
            if err := client.Stream.Send(message); err != nil {
                // å‘é€å¤±è´¥ï¼Œç¨åæ¸…ç†
                continue
            }
        }
    }
}

func (r *Room) addMessage(message *pb.ChatMessage) {
    r.messages = append(r.messages, message)
    
    // ä¿æŒæ¶ˆæ¯æ•°é‡é™åˆ¶
    if len(r.messages) > r.maxMessages {
        r.messages = r.messages[1:]
    }
}

func (r *Room) GetRecentMessages(count int) []*pb.ChatMessage {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    if count > len(r.messages) {
        count = len(r.messages)
    }
    
    start := len(r.messages) - count
    messages := make([]*pb.ChatMessage, count)
    copy(messages, r.messages[start:])
    
    return messages
}

func (r *Room) GetUserCount() int {
    r.mu.RLock()
    defer r.mu.RUnlock()
    return len(r.clients)
}

func (r *Room) GetUserIDs() []string {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    userIDs := make([]string, 0, len(r.clients))
    for userID := range r.clients {
        userIDs = append(userIDs, userID)
    }
    return userIDs
}

func generateMessageID() string {
    return time.Now().Format("20060102150405") + "-" + randomString(8)
}

func randomString(n int) string {
    const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    b := make([]byte, n)
    for i := range b {
        b[i] = letters[time.Now().UnixNano()%int64(len(letters))]
    }
    return string(b)
}
```

**server/handler.go**:
```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    pb "github.com/your-username/chat-service/proto"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

type chatServer struct {
    pb.UnimplementedChatServiceServer
    mu    sync.RWMutex
    rooms map[string]*Room
}

func (s *chatServer) JoinRoom(req *pb.JoinRoomRequest, stream pb.ChatService_JoinRoomServer) error {
    if req.RoomId == "" || req.UserId == "" || req.Username == "" {
        return status.Error(codes.InvalidArgument, "room_id, user_id, and username are required")
    }
    
    // è·å–æˆ–åˆ›å»ºæˆ¿é—´
    room := s.getOrCreateRoom(req.RoomId)
    
    // åˆ›å»ºå®¢æˆ·ç«¯
    ctx, cancel := context.WithCancel(stream.Context())
    client := &Client{
        ID:       req.UserId,
        Username: req.Username,
        RoomID:   req.RoomId,
        Stream:   stream,
        ctx:      ctx,
        cancel:   cancel,
    }
    
    // æ·»åŠ åˆ°æˆ¿é—´
    room.AddClient(client)
    
    // å‘é€å†å²æ¶ˆæ¯
    recentMessages := room.GetRecentMessages(50)
    for _, msg := range recentMessages {
        if err := stream.Send(msg); err != nil {
            return status.Errorf(codes.Internal, "failed to send message: %v", err)
        }
    }
    
    // ç­‰å¾…å®¢æˆ·ç«¯æ–­å¼€
    <-ctx.Done()
    
    // æ¸…ç†å®¢æˆ·ç«¯
    room.RemoveClient(req.UserId)
    
    return nil
}

func (s *chatServer) SendMessage(ctx context.Context, msg *pb.ChatMessage) (*pb.SendMessageResponse, error) {
    if msg.RoomId == "" || msg.UserId == "" || msg.Content == "" {
        return nil, status.Error(codes.InvalidArgument, "room_id, user_id, and content are required")
    }
    
    // è·å–æˆ¿é—´
    s.mu.RLock()
    room, exists := s.rooms[msg.RoomId]
    s.mu.RUnlock()
    
    if !exists {
        return nil, status.Error(codes.NotFound, "room not found")
    }
    
    // è®¾ç½®æ¶ˆæ¯å±æ€§
    msg.Id = generateMessageID()
    msg.Timestamp = time.Now().Format(time.RFC3339)
    if msg.Type == pb.MessageType_MESSAGE_TYPE_UNSPECIFIED {
        msg.Type = pb.MessageType_MESSAGE_TYPE_TEXT
    }
    
    // å¹¿æ’­æ¶ˆæ¯
    room.Broadcast(msg)
    
    return &pb.SendMessageResponse{
        Success:   true,
        MessageId: msg.Id,
    }, nil
}

func (s *chatServer) ListRooms(ctx context.Context, req *pb.ListRoomsRequest) (*pb.ListRoomsResponse, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    rooms := make([]*pb.RoomInfo, 0, len(s.rooms))
    for _, room := range s.rooms {
        rooms = append(rooms, &pb.RoomInfo{
            Id:         room.ID,
            Name:       room.Name,
            UserCount:  int32(room.GetUserCount()),
            CreatedAt:  room.CreatedAt.Format(time.RFC3339),
        })
    }
    
    return &pb.ListRoomsResponse{Rooms: rooms}, nil
}

func (s *chatServer) GetRoomInfo(ctx context.Context, req *pb.GetRoomInfoRequest) (*pb.GetRoomInfoResponse, error) {
    if req.RoomId == "" {
        return nil, status.Error(codes.InvalidArgument, "room_id is required")
    }
    
    s.mu.RLock()
    room, exists := s.rooms[req.RoomId]
    s.mu.RUnlock()
    
    if !exists {
        return nil, status.Error(codes.NotFound, "room not found")
    }
    
    return &pb.GetRoomInfoResponse{
        Room: &pb.RoomInfo{
            Id:         room.ID,
            Name:       room.Name,
            UserCount:  int32(room.GetUserCount()),
            CreatedAt:  room.CreatedAt.Format(time.RFC3339),
        },
        UserIds: room.GetUserIDs(),
    }, nil
}

func (s *chatServer) getOrCreateRoom(roomID string) *Room {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    if room, exists := s.rooms[roomID]; exists {
        return room
    }
    
    room := NewRoom(roomID, fmt.Sprintf("Room %s", roomID))
    s.rooms[roomID] = room
    return room
}
```

### é¡¹ç›®3: å¾®æœåŠ¡æ¶æ„ (é«˜çº§ç‰¹æ€§)

#### 3.1 é¡¹ç›®æ¦‚è¿°
å®ç°ä¸€ä¸ªå®Œæ•´çš„å¾®æœåŠ¡æ¶æ„ï¼ŒåŒ…å«æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡ã€ç›‘æ§ã€è®¤è¯ç­‰é«˜çº§ç‰¹æ€§ã€‚

#### 3.2 æŠ€æœ¯æ ˆ
- **gRPC-Go**: é€šä¿¡æ¡†æ¶
- **Consul**: æœåŠ¡å‘ç°
- **Jaeger**: åˆ†å¸ƒå¼è¿½è¸ª
- **Prometheus**: ç›‘æ§æŒ‡æ ‡
- **JWT**: è®¤è¯æˆæƒ
- **Docker**: å®¹å™¨åŒ–éƒ¨ç½²

#### 3.3 é¡¹ç›®ç»“æ„
```
microservice-demo/
â”œâ”€â”€ proto/
â”‚   â”œâ”€â”€ user.proto
â”‚   â”œâ”€â”€ order.proto
â”‚   â””â”€â”€ payment.proto
â”œâ”€â”€ user-service/
â”œâ”€â”€ order-service/
â”œâ”€â”€ payment-service/
â”œâ”€â”€ gateway/
â”œâ”€â”€ client/
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ README.md
```

#### 3.4 æ ¸å¿ƒç‰¹æ€§å®ç°

**è‡ªå®šä¹‰æ‹¦æˆªå™¨**:
```go
// è®¤è¯æ‹¦æˆªå™¨
func AuthInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    // ä» metadata ä¸­è·å– token
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, status.Error(codes.Unauthenticated, "missing metadata")
    }
    
    tokens := md.Get("authorization")
    if len(tokens) == 0 {
        return nil, status.Error(codes.Unauthenticated, "missing authorization token")
    }
    
    token := tokens[0]
    if !strings.HasPrefix(token, "Bearer ") {
        return nil, status.Error(codes.Unauthenticated, "invalid token format")
    }
    
    // éªŒè¯ token
    claims, err := validateToken(token[7:])
    if err != nil {
        return nil, status.Errorf(codes.Unauthenticated, "invalid token: %v", err)
    }
    
    // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°ä¸Šä¸‹æ–‡
    ctx = context.WithValue(ctx, "user_id", claims.UserID)
    ctx = context.WithValue(ctx, "username", claims.Username)
    
    return handler(ctx, req)
}

// æ—¥å¿—æ‹¦æˆªå™¨
func LoggingInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    start := time.Now()
    
    // è®°å½•è¯·æ±‚æ—¥å¿—
    log.Printf("Request - Method:%s\tDuration:%s\tError:%v",
        info.FullMethod,
        time.Since(start),
        nil)
    
    resp, err := handler(ctx, req)
    
    // è®°å½•å“åº”æ—¥å¿—
    log.Printf("Response - Method:%s\tDuration:%s\tError:%v",
        info.FullMethod,
        time.Since(start),
        err)
    
    return resp, err
}

// ç›‘æ§æ‹¦æˆªå™¨
func MetricsInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    start := time.Now()
    
    resp, err := handler(ctx, req)
    
    // è®°å½•æŒ‡æ ‡
    duration := time.Since(start).Seconds()
    method := info.FullMethod
    
    requestCounter.WithLabelValues(method).Inc()
    requestDuration.WithLabelValues(method).Observe(duration)
    
    if err != nil {
        errorCounter.WithLabelValues(method).Inc()
    }
    
    return resp, err
}
```

**è‡ªå®šä¹‰è´Ÿè½½å‡è¡¡å™¨**:
```go
type weightedRoundRobinBalancer struct {
    subConns []balancer.SubConn
    weights  []int
    current  int
    mu       sync.Mutex
}

func (b *weightedRoundRobinBalancer) UpdateClientConnState(state balancer.ClientConnState) error {
    // æ›´æ–°è¿æ¥çŠ¶æ€
    return nil
}

func (b *weightedRoundRobinBalancer) ResolverError(err error) {
    // å¤„ç†è§£æå™¨é”™è¯¯
}

func (b *weightedRoundRobinBalancer) UpdateSubConnState(sc balancer.SubConn, state balancer.SubConnState) {
    // æ›´æ–°å­è¿æ¥çŠ¶æ€
}

func (b *weightedRoundRobinBalancer) Close() {
    // å…³é—­è´Ÿè½½å‡è¡¡å™¨
}

func (b *weightedRoundRobinBalancer) ExitIdle() {
    // é€€å‡ºç©ºé—²çŠ¶æ€
}

type weightedRoundRobinPicker struct {
    subConns []balancer.SubConn
    weights  []int
    current  int
    mu       sync.Mutex
}

func (p *weightedRoundRobinPicker) Pick(info balancer.PickInfo) (balancer.PickResult, error) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    if len(p.subConns) == 0 {
        return balancer.PickResult{}, balancer.ErrNoSubConnAvailable
    }
    
    // åŠ æƒè½®è¯¢ç®—æ³•
    for i := 0; i < len(p.subConns); i++ {
        p.current = (p.current + 1) % len(p.subConns)
        if p.weights[p.current] > 0 {
            return balancer.PickResult{
                SubConn: p.subConns[p.current],
            }, nil
        }
    }
    
    return balancer.PickResult{}, balancer.ErrNoSubConnAvailable
}
```

## ğŸš€ éƒ¨ç½²å’Œè¿ç»´

### Docker éƒ¨ç½²
```yaml
# docker-compose.yml
version: '3.8'

services:
  user-service:
    build: ./user-service
    ports:
      - "50051:50051"
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=users
      - DB_USER=postgres
      - DB_PASSWORD=password
    depends_on:
      - postgres
      - redis
      - consul

  order-service:
    build: ./order-service
    ports:
      - "50052:50052"
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=orders
      - DB_USER=postgres
      - DB_PASSWORD=password
    depends_on:
      - postgres
      - redis
      - consul

  gateway:
    build: ./gateway
    ports:
      - "8080:8080"
    environment:
      - CONSUL_HOST=consul
      - CONSUL_PORT=8500
    depends_on:
      - consul

  postgres:
    image: postgres:13
    environment:
      - POSTGRES_DB=users
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"

  consul:
    image: consul:1.11
    ports:
      - "8500:8500"
    command: agent -server -bootstrap-expect=1 -ui -client=0.0.0.0

  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      - "14268:14268"

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  postgres_data:
  grafana_data:
```

### ç›‘æ§é…ç½®
```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'user-service'
    static_configs:
      - targets: ['user-service:50051']
    metrics_path: '/metrics'

  - job_name: 'order-service'
    static_configs:
      - targets: ['order-service:50052']
    metrics_path: '/metrics'

  - job_name: 'gateway'
    static_configs:
      - targets: ['gateway:8080']
    metrics_path: '/metrics'
```

## ğŸ“Š æ€§èƒ½æµ‹è¯•

### åŸºå‡†æµ‹è¯•
```go
func BenchmarkUserService_CreateUser(b *testing.B) {
    // è®¾ç½®æµ‹è¯•ç¯å¢ƒ
    conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
    if err != nil {
        b.Fatalf("failed to connect: %v", err)
    }
    defer conn.Close()
    
    client := pb.NewUserServiceClient(conn)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        req := &pb.CreateUserRequest{
            Username: fmt.Sprintf("user%d", i),
            Email:    fmt.Sprintf("user%d@example.com", i),
            FullName: fmt.Sprintf("User %d", i),
        }
        
        _, err := client.CreateUser(context.Background(), req)
        if err != nil {
            b.Errorf("CreateUser failed: %v", err)
        }
    }
}
```

### è´Ÿè½½æµ‹è¯•
```go
func TestUserService_LoadTest(t *testing.T) {
    // å¹¶å‘æµ‹è¯•
    const numGoroutines = 100
    const requestsPerGoroutine = 100
    
    var wg sync.WaitGroup
    results := make(chan time.Duration, numGoroutines*requestsPerGoroutine)
    
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
            if err != nil {
                t.Errorf("failed to connect: %v", err)
                return
            }
            defer conn.Close()
            
            client := pb.NewUserServiceClient(conn)
            
            for j := 0; j < requestsPerGoroutine; j++ {
                start := time.Now()
                
                req := &pb.CreateUserRequest{
                    Username: fmt.Sprintf("user_%d_%d", id, j),
                    Email:    fmt.Sprintf("user_%d_%d@example.com", id, j),
                    FullName: fmt.Sprintf("User %d-%d", id, j),
                }
                
                _, err := client.CreateUser(context.Background(), req)
                if err != nil {
                    t.Errorf("CreateUser failed: %v", err)
                    continue
                }
                
                results <- time.Since(start)
            }
        }(i)
    }
    
    wg.Wait()
    close(results)
    
    // ç»Ÿè®¡ç»“æœ
    var total time.Duration
    var count int
    for duration := range results {
        total += duration
        count++
    }
    
    avg := total / time.Duration(count)
    t.Logf("Average response time: %v", avg)
    t.Logf("Total requests: %d", count)
}
```

## ğŸ¯ å­¦ä¹ æˆæœ

é€šè¿‡å®Œæˆè¿™äº›å®è·µé¡¹ç›®ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

1. **æŒæ¡ gRPC-Go æ ¸å¿ƒæ¦‚å¿µ**: æ·±å…¥ç†è§£ RPCã€æµå¼é€šä¿¡ã€æ‹¦æˆªå™¨ç­‰
2. **ç†Ÿç»ƒä½¿ç”¨é«˜çº§ç‰¹æ€§**: è´Ÿè½½å‡è¡¡ã€æœåŠ¡å‘ç°ã€ç›‘æ§ã€è®¤è¯ç­‰
3. **å…·å¤‡ç³»ç»Ÿè®¾è®¡èƒ½åŠ›**: èƒ½å¤Ÿè®¾è®¡å¯æ‰©å±•çš„å¾®æœåŠ¡æ¶æ„
4. **æŒæ¡æ€§èƒ½ä¼˜åŒ–**: ç†è§£æ€§èƒ½ç“¶é¢ˆå’Œä¼˜åŒ–ç­–ç•¥
5. **å…·å¤‡è¿ç»´èƒ½åŠ›**: èƒ½å¤Ÿéƒ¨ç½²å’Œç›‘æ§ç”Ÿäº§ç¯å¢ƒ

è¿™äº›é¡¹ç›®å°†å¸®åŠ©æ‚¨å»ºç«‹èµ·å¯¹ gRPC-Go å’Œåˆ†å¸ƒå¼ç³»ç»Ÿçš„æ·±åˆ»è®¤çŸ¥ï¼Œä¸ºå®é™…é¡¹ç›®å¼€å‘æ‰“ä¸‹åšå®åŸºç¡€ï¼ 